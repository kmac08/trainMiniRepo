Index: CTC/Core/block.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\nBlock Module\n===========\nDefines the Block class according to UML specifications.\nManages individual track blocks with occupation tracking and switch information.\n\nThis module handles:\n- Block occupation status\n- Switch position management\n- Crossing status\n- Scheduled occupations and closures\n- Authority and speed calculations\n\"\"\"\n\nfrom typing import List, Optional\nfrom datetime import datetime\nimport logging\n\n# Set up logging\nlogger = logging.getLogger(__name__)\n\n\nclass Block:\n    \"\"\"\n    Block class implementing UML interface\n    Represents a single track block with all associated infrastructure\n    \"\"\"\n    \n    def __init__(self, track_block_data):\n        \"\"\"\n        Initialize Block with data from Track Reader\n        \n        Args:\n            track_block_data: TrackBlock object from Track_Reader\n        \"\"\"\n        # Attributes from UML\n        self.blockID = track_block_data.block_number\n        self.block_number = track_block_data.block_number  # For UI compatibility\n        self.length = track_block_data.length_m\n        self.grade = track_block_data.grade_percent\n        self.speedLimit = track_block_data.speed_limit_kmh\n        self.stationaryStatus = True  # Operational status (True = operational)\n        self.switchPosition = False   # Current switch position if applicable\n        self.switchPresent = track_block_data.has_switch\n        self.crossingPresent = track_block_data.has_crossing\n        self.crossingStatus = False   # Crossing active status\n        self.circuitPresent = True    # All blocks have track circuits\n        self.scheduledOccupations = []  # List[datetime]\n        self.scheduledClosures = []     # List[datetime]\n        self.occupyingTrain = None      # Train object currently in block\n        \n        # Additional attributes needed for implementation\n        self.authority = 0              # Current authority (0 or 1)\n        self.suggestedSpeed = 0         # Current speed command (0-3)\n        self.track_circuit_failed = False\n        self.power_rail_status = True\n        self.line = track_block_data.line\n        self.section = track_block_data.section\n        self.elevation = track_block_data.elevation_m\n        self.direction = track_block_data.direction\n        self.is_underground = track_block_data.is_underground\n        \n        # Infrastructure objects\n        self.station = track_block_data.station if track_block_data.has_station else None\n        self.switch = track_block_data.switch if track_block_data.has_switch else None\n        \n        # Occupancy tracking\n        self.occupied = False\n        self.last_occupancy_change = None\n        self.occupancy_history = []\n        \n        # Maintenance and failure tracking\n        self.maintenance_mode = False\n        self.failure_mode = False\n        self.last_maintenance = None\n        \n        logger.debug(f\"Block {self.blockID} initialized on {self.line} line\")\n    \n    # Methods from UML\n    \n    def update_occupation(self, occupied: bool) -> None:\n        \"\"\"\n        Update block occupation status\n        \n        Args:\n            occupied: True if block is occupied, False otherwise\n        \"\"\"\n        if self.occupied != occupied:\n            self.occupied = occupied\n            self.last_occupancy_change = datetime.now()\n            \n            # Update occupancy history\n            self.occupancy_history.append({\n                'timestamp': self.last_occupancy_change,\n                'occupied': occupied,\n                'train': self.occupyingTrain\n            })\n            \n            # Keep only last 100 occupancy changes\n            if len(self.occupancy_history) > 100:\n                self.occupancy_history = self.occupancy_history[-100:]\n            \n            logger.debug(f\"Block {self.blockID} occupation updated: {occupied}\")\n    \n    def get_switch_info(self) -> bool:\n        \"\"\"\n        Get current switch position\n        \n        Returns:\n            Current switch position (0=normal/lower block, 1=reverse/higher block)\n            Returns False if no switch present\n        \"\"\"\n        if self.switchPresent:\n            return self.switchPosition\n        return False\n    \n    def setCrossing_status(self, status: bool) -> None:\n        \"\"\"\n        Set railway crossing status\n        \n        Args:\n            status: True if crossing is active, False otherwise\n        \"\"\"\n        if self.crossingPresent:\n            old_status = self.crossingStatus\n            self.crossingStatus = status\n            \n            if old_status != status:\n                logger.info(f\"Block {self.blockID} crossing status changed: {status}\")\n        else:\n            logger.warning(f\"Block {self.blockID} has no crossing - cannot set status\")\n    \n    def setBlock_status(self, status: bool) -> None:\n        \"\"\"\n        Set block operational status\n        \n        Args:\n            status: True if block is operational, False if failed/closed\n        \"\"\"\n        old_status = self.stationaryStatus\n        self.stationaryStatus = status\n        \n        if old_status != status:\n            if not status:\n                self.failure_mode = True\n                logger.warning(f\"Block {self.blockID} set to non-operational\")\n            else:\n                self.failure_mode = False\n                logger.info(f\"Block {self.blockID} restored to operational\")\n    \n    def block_operational(self) -> bool:\n        \"\"\"\n        Check if block is operational\n        \n        Returns:\n            True if block is operational and safe for trains\n        \"\"\"\n        return (self.stationaryStatus and \n                not self.failure_mode and \n                not self.track_circuit_failed and \n                self.power_rail_status)\n    \n    def update_scheduled_occupancy(self, times: List[datetime]) -> None:\n        \"\"\"\n        Update scheduled occupations\n        \n        Args:\n            times: List of datetime objects when block will be occupied\n        \"\"\"\n        self.scheduledOccupations = times.copy()\n        logger.debug(f\"Block {self.blockID} scheduled occupations updated: {len(times)} times\")\n    \n    def block_occupation(self) -> List[datetime]:\n        \"\"\"\n        Get scheduled occupations\n        \n        Returns:\n            List of datetime objects when block is scheduled to be occupied\n        \"\"\"\n        return self.scheduledOccupations.copy()\n    \n    def add_train(self, train) -> None:\n        \"\"\"\n        Add train to block\n        \n        Args:\n            train: Train object entering the block\n        \"\"\"\n        if self.occupyingTrain is not None and self.occupyingTrain != train:\n            logger.error(f\"Block {self.blockID} already occupied by different train!\")\n            return\n        \n        self.occupyingTrain = train\n        self.update_occupation(True)\n        \n        # Update train's current block if possible\n        if hasattr(train, 'currentBlock'):\n            train.currentBlock = self.blockID\n        \n        logger.info(f\"Train {self._get_train_id(train)} entered block {self.blockID}\")\n    \n    def remove_train(self) -> None:\n        \"\"\"Remove train from block\"\"\"\n        if self.occupyingTrain:\n            train_id = self._get_train_id(self.occupyingTrain)\n            self.occupyingTrain = None\n            self.update_occupation(False)\n            logger.info(f\"Train {train_id} left block {self.blockID}\")\n        else:\n            logger.warning(f\"No train to remove from block {self.blockID}\")\n    \n    def get_occupying_train(self):\n        \"\"\"\n        Get current occupying train\n        \n        Returns:\n            Train object currently in block, or None if empty\n        \"\"\"\n        return self.occupyingTrain\n    \n    # Additional methods needed for implementation\n    \n    def calculate_safe_authority(self, next_blocks: List['Block']) -> int:\n        \"\"\"\n        Calculate safe authority based on ahead conditions\n        \n        Args:\n            next_blocks: List of blocks ahead in train's path\n            \n        Returns:\n            Authority value (0=no authority, 1=full authority)\n        \"\"\"\n        # Check if current block is operational\n        if not self.block_operational():\n            return 0\n        \n        # Check next blocks for obstacles\n        for block in next_blocks:\n            if not block.block_operational():\n                return 0  # Stop before failed block\n            if block.occupied:\n                return 0  # Stop before occupied block\n            if block.maintenance_mode:\n                return 0  # Stop before maintenance\n        \n        # Check for switch conflicts\n        if self.switchPresent and not self._switch_aligned_for_route(next_blocks):\n            return 0\n        \n        return 1  # Safe to proceed\n    \n    def calculate_suggested_speed(self, train_state: dict, track_conditions: dict) -> int:\n        \"\"\"\n        Calculate speed command based on conditions\n        \n        Args:\n            train_state: Current train state information\n            track_conditions: Current track conditions\n            \n        Returns:\n            Speed command (0=stop, 1=1/3 speed, 2=2/3 speed, 3=full speed)\n        \"\"\"\n        # Check for immediate stops\n        if not self.block_operational():\n            return 0\n        \n        if self.crossingPresent and self.crossingStatus:\n            return 0  # Stop for active crossing\n        \n        # Check grade and speed limits\n        if abs(self.grade) > 5.0:  # Steep grade\n            return 1  # Reduced speed\n        \n        # Weather/environmental conditions\n        weather = track_conditions.get('weather', 'clear')\n        if weather in ['rain', 'snow', 'ice']:\n            return 2  # Reduced speed for weather\n        \n        # Normal operations - respect speed limit\n        current_speed = train_state.get('speed', 0)\n        if current_speed > self.speedLimit * 0.8:\n            return 2  # Approach speed limit\n        \n        return 3  # Full speed\n    \n    def set_switch_position(self, position: bool) -> None:\n        \"\"\"\n        Set switch position\n        \n        Args:\n            position: Switch position (0=normal/lower, 1=reverse/higher)\n        \"\"\"\n        if self.switchPresent:\n            old_position = self.switchPosition\n            self.switchPosition = position\n            \n            if old_position != position:\n                position_name = \"reverse (higher)\" if position else \"normal (lower)\"\n                logger.info(f\"Block {self.blockID} switch set to {position_name}\")\n        else:\n            logger.warning(f\"Block {self.blockID} has no switch\")\n    \n    def schedule_closure(self, start_time: datetime, end_time: datetime) -> None:\n        \"\"\"\n        Schedule block closure for maintenance\n        \n        Args:\n            start_time: When closure begins\n            end_time: When closure ends\n        \"\"\"\n        self.scheduledClosures.append({\n            'start': start_time,\n            'end': end_time,\n            'type': 'maintenance'\n        })\n        \n        logger.info(f\"Block {self.blockID} closure scheduled: {start_time} to {end_time}\")\n    \n    def is_closed_at_time(self, check_time: datetime) -> bool:\n        \"\"\"\n        Check if block is closed at specific time\n        \n        Args:\n            check_time: Time to check\n            \n        Returns:\n            True if block is closed at that time\n        \"\"\"\n        for closure in self.scheduledClosures:\n            if closure['start'] <= check_time <= closure['end']:\n                return True\n        return False\n    \n    def get_next_valid_blocks(self, direction: str = None) -> List[int]:\n        \"\"\"\n        Get list of valid next blocks based on track layout\n        \n        Args:\n            direction: Optional direction constraint\n            \n        Returns:\n            List of block numbers that can be reached from this block\n        \"\"\"\n        valid_blocks = []\n        \n        if self.switchPresent and self.switch:\n            # Get switch connections\n            for connection in self.switch.connections:\n                if connection.from_block == self.blockID:\n                    valid_blocks.append(connection.to_block)\n        else:\n            # Simple progression\n            if direction == 'forward' or direction is None:\n                valid_blocks.append(self.blockID + 1)\n            if direction == 'backward' or direction is None:\n                valid_blocks.append(self.blockID - 1)\n        \n        return valid_blocks\n    \n    def get_infrastructure_info(self) -> dict:\n        \"\"\"\n        Get complete infrastructure information\n        \n        Returns:\n            Dict containing all infrastructure details\n        \"\"\"\n        return {\n            'blockID': self.blockID,\n            'line': self.line,\n            'section': self.section,\n            'length': self.length,\n            'grade': self.grade,\n            'speed_limit': self.speedLimit,\n            'elevation': self.elevation,\n            'underground': self.is_underground,\n            'station': self.station.name if self.station else None,\n            'switch_present': self.switchPresent,\n            'switch_position': self.switchPosition if self.switchPresent else None,\n            'crossing_present': self.crossingPresent,\n            'crossing_active': self.crossingStatus if self.crossingPresent else None,\n            'occupied': self.occupied,\n            'operational': self.block_operational(),\n            'maintenance_mode': self.maintenance_mode\n        }\n    \n    # Private helper methods\n    \n    def _switch_aligned_for_route(self, next_blocks: List['Block']) -> bool:\n        \"\"\"Check if switch is properly aligned for route\"\"\"\n        if not self.switchPresent or not next_blocks:\n            return True\n        \n        # Get intended next block\n        next_block = next_blocks[0]\n        next_block_id = next_block.blockID\n        \n        # Check switch alignment\n        if self.switch:\n            for connection in self.switch.connections:\n                if (connection.from_block == self.blockID and \n                    connection.to_block == next_block_id):\n                    # Determine required switch position\n                    required_position = next_block_id > self.blockID\n                    return self.switchPosition == required_position\n        \n        return False\n    \n    def _get_train_id(self, train) -> str:\n        \"\"\"Extract train ID from train object\"\"\"\n        if hasattr(train, 'trainID'):\n            return str(train.trainID)\n        elif hasattr(train, 'id'):\n            return str(train.id)\n        else:\n            return f\"train_{id(train)}\"\n    \n    def __str__(self) -> str:\n        \"\"\"String representation of block\"\"\"\n        status = \"occupied\" if self.occupied else \"empty\"\n        return f\"Block {self.blockID} ({self.line} Line, {status})\"\n    \n    def __repr__(self) -> str:\n        \"\"\"Detailed representation of block\"\"\"\n        return (f\"Block(id={self.blockID}, line={self.line}, \"\n                f\"occupied={self.occupied}, operational={self.block_operational()})\")
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/CTC/Core/block.py b/CTC/Core/block.py
--- a/CTC/Core/block.py	(revision 58821640d3fc1243a45beca7e2f7ac46d5ad7247)
+++ b/CTC/Core/block.py	(date 1752438154120)
@@ -64,6 +64,10 @@
         self.station = track_block_data.station if track_block_data.has_station else None
         self.switch = track_block_data.switch if track_block_data.has_switch else None
         
+        # Connected blocks data - NEW: from Track Reader connected_blocks
+        self.connected_blocks = track_block_data.connected_blocks.copy() if hasattr(track_block_data, 'connected_blocks') else []
+        self.has_yard_connection = track_block_data.has_yard_connection if hasattr(track_block_data, 'has_yard_connection') else False
+        
         # Occupancy tracking
         self.occupied = False
         self.last_occupancy_change = None
@@ -333,7 +337,7 @@
     
     def get_next_valid_blocks(self, direction: str = None) -> List[int]:
         """
-        Get list of valid next blocks based on track layout
+        Get list of valid next blocks based on track layout using connected_blocks data
         
         Args:
             direction: Optional direction constraint
@@ -341,6 +345,11 @@
         Returns:
             List of block numbers that can be reached from this block
         """
+        # Use connected_blocks data if available (NEW: from Track Reader)
+        if self.connected_blocks:
+            return [block_num for block_num in self.connected_blocks if block_num != -1]
+        
+        # Fallback to legacy switch/sequential logic
         valid_blocks = []
         
         if self.switchPresent and self.switch:
@@ -380,8 +389,40 @@
             'crossing_active': self.crossingStatus if self.crossingPresent else None,
             'occupied': self.occupied,
             'operational': self.block_operational(),
-            'maintenance_mode': self.maintenance_mode
+            'maintenance_mode': self.maintenance_mode,
+            'connected_blocks': self.connected_blocks,
+            'has_yard_connection': self.has_yard_connection
         }
+    
+    def is_connected_to(self, block_number: int) -> bool:
+        """
+        Check if this block is directly connected to the specified block number
+        
+        Args:
+            block_number: Block number to check connection to
+            
+        Returns:
+            True if this block connects directly to the specified block
+        """
+        return block_number in self.connected_blocks
+    
+    def leads_to_yard(self) -> bool:
+        """
+        Check if this block has a connection to the yard
+        
+        Returns:
+            True if this block connects to the yard
+        """
+        return self.has_yard_connection
+    
+    def get_connected_blocks(self) -> List[int]:
+        """
+        Get list of block numbers this block connects to (excluding yard)
+        
+        Returns:
+            List of block numbers this block connects to
+        """
+        return [block_num for block_num in self.connected_blocks if block_num != -1]
     
     # Private helper methods
     
Index: Track_Reader/track_reader.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\nTrack Layout Reader for Train Control System\n============================================\nThis module reads track layout data from Excel files and provides\neasy-to-use data structures for the CTC Office, Track Controller,\nand Track Model components.\n\nDesigned with non-technical dispatchers in mind - provides clear,\nintuitive access to track information.\n\"\"\"\n\nimport pandas as pd\nimport json\nimport re\nfrom typing import Dict, List, Optional, Tuple, Union\nfrom dataclasses import dataclass, asdict\nfrom enum import Enum\n\n\n# Debug flag - set to True to enable detailed debugging output\nDEBUG_PARSING = False\nDEBUG_SHOW_ALL_OBJECTS = False  # New flag for comprehensive object dump\n\n# To turn off debug output:\n# Set DEBUG_PARSING = False to disable parsing debug messages\n# Set DEBUG_SHOW_ALL_OBJECTS = False to disable the comprehensive object dump\n\n\nclass InfrastructureType(Enum):\n    \"\"\"Types of infrastructure that can exist on a track block\"\"\"\n    STATION = \"STATION\"\n    SWITCH = \"SWITCH\"\n    CROSSING = \"CROSSING\"\n    NONE = \"NONE\"\n\n\nclass SwitchDirection(Enum):\n    \"\"\"Direction restrictions for switches\"\"\"\n    BIDIRECTIONAL = \"BIDIRECTIONAL\"  # Traffic can flow both ways\n    TO_ONLY = \"TO_ONLY\"              # Traffic can only go TO the destination\n    FROM_ONLY = \"FROM_ONLY\"          # Traffic can only come FROM the destination\n\n\nclass BlockDirection(Enum):\n    \"\"\"Direction of allowed movement for a track block\"\"\"\n    FORWARD = \"FORWARD\"           # Movement to higher block numbers\n    BACKWARD = \"BACKWARD\"         # Movement to lower block numbers\n    BIDIRECTIONAL = \"BIDIRECTIONAL\"  # Movement in either direction\n\n\n@dataclass\nclass Station:\n    \"\"\"Represents a station on the track\"\"\"\n    name: str\n    side: str  # \"Left\", \"Right\", or \"Both\"\n    station_id: int  # Unique numbered identifier for the station\n\n    def __str__(self):\n        return f\"Station {self.station_id}: {self.name} (Platform: {self.side} side)\"\n\n\n@dataclass\nclass SwitchConnection:\n    \"\"\"Represents a single connection in a switch\"\"\"\n    from_block: Union[int, str]  # Block number or \"yard\"\n    to_block: Union[int, str]    # Block number or \"yard\"\n    direction: SwitchDirection = SwitchDirection.BIDIRECTIONAL\n\n    def __str__(self):\n        from_str = f\"Block {self.from_block}\" if isinstance(self.from_block, int) else str(self.from_block).title()\n        to_str = f\"Block {self.to_block}\" if isinstance(self.to_block, int) else str(self.to_block).title()\n\n        if self.direction == SwitchDirection.BIDIRECTIONAL:\n            return f\"{from_str} ↔ {to_str}\"\n        elif self.direction == SwitchDirection.TO_ONLY:\n            return f\"{from_str} → {to_str}\"\n        else:  # FROM_ONLY\n            return f\"{from_str} ← {to_str}\"\n\n\n@dataclass\nclass Switch:\n    \"\"\"Represents a track switch with multiple possible connections\"\"\"\n    connections: List[SwitchConnection]\n    switch_type: str = \"STANDARD\"  # \"STANDARD\", \"YARD_TO\", \"YARD_FROM\", \"YARD_TO_FROM\"\n    normal_state: int = 0  # 0 = normal (connected to lower block number), 1 = reverse (connected to higher block number)\n    current_state: int = 0  # Current switch position (0 = normal, 1 = reverse)\n\n    def __str__(self):\n        if len(self.connections) == 1:\n            return f\"Switch: {self.connections[0]}\"\n        else:\n            conn_strs = [str(conn) for conn in self.connections]\n            return f\"Switch: {'; '.join(conn_strs)}\"\n\n    def get_destinations_from_block(self, block: Union[int, str]) -> List[Union[int, str]]:\n        \"\"\"Get all possible destinations from a given block\"\"\"\n        destinations = []\n        for conn in self.connections:\n            if conn.from_block == block and conn.direction != SwitchDirection.FROM_ONLY:\n                destinations.append(conn.to_block)\n            elif conn.to_block == block and conn.direction != SwitchDirection.TO_ONLY:\n                destinations.append(conn.from_block)\n        return destinations\n\n    def can_travel_between(self, from_block: Union[int, str], to_block: Union[int, str]) -> bool:\n        \"\"\"Check if travel is allowed between two blocks through this switch\"\"\"\n        for conn in self.connections:\n            if ((conn.from_block == from_block and conn.to_block == to_block and\n                 conn.direction != SwitchDirection.FROM_ONLY) or\n                (conn.from_block == to_block and conn.to_block == from_block and\n                 conn.direction != SwitchDirection.TO_ONLY)):\n                return True\n        return False\n\n    def set_normal_state_from_blocks(self):\n        \"\"\"Set the normal state based on which connection has the lower block number\"\"\"\n        if not self.connections:\n            return\n        \n        # Find the connection with the lowest block number\n        min_block = float('inf')\n        for conn in self.connections:\n            # Only consider numeric blocks (not yard connections)\n            if isinstance(conn.from_block, int):\n                min_block = min(min_block, conn.from_block)\n            if isinstance(conn.to_block, int):\n                min_block = min(min_block, conn.to_block)\n        \n        # Normal state (0) connects to lower block number\n        self.normal_state = 0\n        self.current_state = 0\n\n    def get_state_description(self) -> str:\n        \"\"\"Get human-readable description of switch state\"\"\"\n        state_str = \"Normal\" if self.current_state == 0 else \"Reverse\"\n        return f\"Switch state: {state_str} ({self.current_state})\"\n\n\n@dataclass\nclass TrackBlock:\n    \"\"\"\n    Represents a single block of track.\n    All information a dispatcher needs about a track segment.\n    \"\"\"\n    line: str  # \"Blue\", \"Red\", or \"Green\"\n    section: str  # Section letter (A, B, C, etc.)\n    block_number: int\n    length_m: float  # Length in meters\n    grade_percent: float  # Grade as percentage\n    speed_limit_kmh: float  # Speed limit in km/hr\n    elevation_m: float  # Elevation in meters\n    direction: BlockDirection = BlockDirection.BIDIRECTIONAL  # Direction of allowed movement\n\n    # Infrastructure on this block\n    has_station: bool = False\n    station: Optional[Station] = None\n    has_switch: bool = False\n    switch: Optional[Switch] = None\n    has_crossing: bool = False\n    is_underground: bool = False  # New attribute for underground sections\n\n    # Calculated fields - minimum time to traverse at speed limit\n    min_traversal_time_seconds: float = 0.0  # Minimum time to traverse this block\n\n    def can_move_to_block(self, target_block_number: int) -> bool:\n        \"\"\"\n        Check if movement is allowed from this block to the target block.\n\n        Args:\n            target_block_number: Block number to move to\n\n        Returns:\n            True if movement is allowed based on block direction\n        \"\"\"\n        if self.direction == BlockDirection.BIDIRECTIONAL:\n            return True\n        elif self.direction == BlockDirection.FORWARD:\n            return target_block_number > self.block_number\n        elif self.direction == BlockDirection.BACKWARD:\n            return target_block_number < self.block_number\n        else:\n            return True  # Default to allowing movement\n\n    def get_direction_description(self) -> str:\n        \"\"\"Get human-readable description of block direction\"\"\"\n        if self.direction == BlockDirection.FORWARD:\n            return f\"Forward only (→ higher block numbers)\"\n        elif self.direction == BlockDirection.BACKWARD:\n            return f\"Backward only (→ lower block numbers)\"\n        else:\n            return \"Bidirectional (↔)\"\n\n    def get_infrastructure_description(self) -> str:\n        \"\"\"Get human-readable description of infrastructure\"\"\"\n        items = []\n        if self.has_station and self.station:\n            items.append(str(self.station))\n        if self.has_switch and self.switch:\n            items.append(str(self.switch))\n        if self.has_crossing:\n            items.append(\"Railway Crossing\")\n        if self.is_underground:\n            items.append(\"Underground\")\n\n        return \"; \".join(items) if items else \"No special infrastructure\"\n\n\nclass TrackLayoutReader:\n    \"\"\"\n    Main class for reading and managing track layout data.\n    Provides easy access to track information for dispatchers.\n    \"\"\"\n\n    def __init__(self, excel_file_path: str, selected_lines: List[str] = None):\n        \"\"\"\n        Initialize the track layout reader with an Excel file.\n\n        Args:\n            excel_file_path: Path to the track layout Excel file\n            selected_lines: List of lines to load (e.g., ['Blue', 'Red']). \n                          If None, loads all lines.\n        \"\"\"\n        self.file_path = excel_file_path\n        \n        # Default to all lines if none specified\n        if selected_lines is None:\n            selected_lines = [\"Blue\", \"Red\", \"Green\"]\n        \n        self.selected_lines = selected_lines\n        \n        # Initialize data structures only for selected lines\n        self.lines: Dict[str, List[TrackBlock]] = {}\n        self.sections: Dict[str, Dict[str, List[int]]] = {}\n        \n        # Station counter for unique IDs\n        self.station_counter = 0\n        \n        for line in selected_lines:\n            self.lines[line] = []\n            self.sections[line] = {}\n        \n        self._load_track_data()\n\n        # Debug output all objects if enabled\n        if DEBUG_SHOW_ALL_OBJECTS:\n            self._debug_print_all_objects()\n\n    def _debug_print(self, *args, **kwargs):\n        \"\"\"Print debug information only if DEBUG_PARSING is True\"\"\"\n        if DEBUG_PARSING:\n            print(\"[DEBUG]\", *args, **kwargs)\n\n    def _debug_print_all_objects(self):\n        \"\"\"Print comprehensive debug output of all parsed objects\"\"\"\n        print(\"\\n\" + \"=\"*80)\n        print(\"=== COMPREHENSIVE DEBUG OUTPUT - ALL PARSED OBJECTS ===\")\n        print(\"=\"*80)\n\n        for line_name in self.selected_lines:\n            print(f\"\\n=== {line_name.upper()} LINE ===\")\n            blocks = self.lines.get(line_name, [])\n            print(f\"Total blocks: {len(blocks)}\")\n\n            # Print sections summary\n            sections = self.sections.get(line_name, {})\n            print(f\"Sections: {list(sections.keys())}\")\n\n            # Print detailed block information\n            print(f\"\\nDetailed Block Information for {line_name} Line:\")\n            print(\"-\" * 70)\n\n            for block in blocks:\n                print(f\"\\nBlock #{block.block_number} (Section {block.section}):\")\n                print(f\"  Length: {block.length_m}m\")\n                print(f\"  Speed Limit: {block.speed_limit_kmh} km/hr\")\n                print(f\"  Grade: {block.grade_percent}%\")\n                print(f\"  Elevation: {block.elevation_m}m\")\n                print(f\"  Direction: {block.get_direction_description()}\")\n                print(f\"  Min Traversal Time: {block.min_traversal_time_seconds:.1f} seconds\")\n\n                # Infrastructure details\n                if block.has_station or block.has_switch or block.has_crossing or block.is_underground:\n                    print(f\"  Infrastructure:\")\n                    if block.has_station and block.station:\n                        print(f\"    - Station: '{block.station.name}' (Platform: {block.station.side})\")\n                    if block.has_switch and block.switch:\n                        print(f\"    - Switch: {block.switch}\")\n                        print(f\"      Type: {block.switch.switch_type}\")\n                        print(f\"      Connections:\")\n                        for i, conn in enumerate(block.switch.connections):\n                            print(f\"        {i+1}. {conn}\")\n                    if block.has_crossing:\n                        print(f\"    - Railway Crossing\")\n                    if block.is_underground:\n                        print(f\"    - Underground\")\n                else:\n                    print(f\"  Infrastructure: None\")\n\n            # Summary statistics\n            print(f\"\\n{line_name} Line Statistics:\")\n            print(f\"  Total Blocks: {len(blocks)}\")\n            print(f\"  Stations: {sum(1 for b in blocks if b.has_station)}\")\n            print(f\"  Switches: {sum(1 for b in blocks if b.has_switch)}\")\n            print(f\"  Crossings: {sum(1 for b in blocks if b.has_crossing)}\")\n            print(f\"  Underground: {sum(1 for b in blocks if b.is_underground)}\")\n\n            # List all stations with details\n            stations = [b for b in blocks if b.has_station and b.station]\n            if stations:\n                print(f\"\\n  All Stations on {line_name} Line:\")\n                for b in stations:\n                    print(f\"    - Block {b.block_number}: '{b.station.name}' ({b.station.side} platform)\")\n\n            # List all switches with details\n            switches = [b for b in blocks if b.has_switch and b.switch]\n            if switches:\n                print(f\"\\n  All Switches on {line_name} Line:\")\n                for b in switches:\n                    print(f\"    - Block {b.block_number}: {b.switch}\")\n\n        print(\"\\n\" + \"=\"*80)\n        print(\"=== END OF DEBUG OUTPUT ===\")\n        print(\"=\"*80 + \"\\n\")\n\n    def _parse_switch_string(self, switch_str: str, block_num: int) -> Optional[Switch]:\n        \"\"\"\n        Parse switch string into Switch object.\n\n        Handles formats:\n        - Switch (5-6): Simple bidirectional switch\n        - Switch (5-6; 5-11): Multi-destination switch\n        - SWITCH TO/FROM YARD (75-yard): Bidirectional yard connection\n        - SWITCH TO YARD (57-yard): One-way to yard\n        - SWITCH FROM YARD (Yard-63): One-way from yard\n        \"\"\"\n        self._debug_print(f\"    Parsing switch string: '{switch_str}'\")\n\n        switch_str_upper = switch_str.upper()\n        connections = []\n        switch_type = \"STANDARD\"\n\n        # Extract content within parentheses\n        paren_match = re.search(r'\\((.*?)\\)', switch_str)\n        if not paren_match:\n            self._debug_print(f\"    No parentheses found in switch string\")\n            return None\n\n        connections_str = paren_match.group(1).strip()\n        self._debug_print(f\"    Connections string: '{connections_str}'\")\n\n        # Determine switch type and direction from the prefix\n        direction = SwitchDirection.BIDIRECTIONAL\n        if \"TO/FROM YARD\" in switch_str_upper or \"FROM/TO YARD\" in switch_str_upper:\n            switch_type = \"YARD_TO_FROM\"\n            direction = SwitchDirection.BIDIRECTIONAL\n        elif \"TO YARD\" in switch_str_upper:\n            switch_type = \"YARD_TO\"\n            direction = SwitchDirection.TO_ONLY\n        elif \"FROM YARD\" in switch_str_upper:\n            switch_type = \"YARD_FROM\"\n            direction = SwitchDirection.FROM_ONLY\n\n        # Split connections by semicolon\n        connection_parts = [part.strip() for part in connections_str.split(';')]\n\n        for part in connection_parts:\n            if not part:\n                continue\n\n            self._debug_print(f\"      Processing connection part: '{part}'\")\n\n            # Parse individual connection (e.g., \"5-6\", \"75-yard\", \"yard-63\")\n            connection_match = re.match(r'(\\w+)\\s*-\\s*(\\w+)', part.lower())\n            if connection_match:\n                from_str = connection_match.group(1).strip()\n                to_str = connection_match.group(2).strip()\n\n                # Convert to appropriate types (int for block numbers, str for yard)\n                from_block = int(from_str) if from_str.isdigit() else from_str\n                to_block = int(to_str) if to_str.isdigit() else to_str\n\n                # Create connection with appropriate direction\n                conn = SwitchConnection(\n                    from_block=from_block,\n                    to_block=to_block,\n                    direction=direction\n                )\n\n                connections.append(conn)\n                self._debug_print(f\"        Added connection: {conn}\")\n            else:\n                self._debug_print(f\"        Could not parse connection: '{part}'\")\n\n        if connections:\n            switch = Switch(connections=connections, switch_type=switch_type)\n            # Set normal state based on block numbers\n            switch.set_normal_state_from_blocks()\n            self._debug_print(f\"    Created switch: {switch}\")\n            self._debug_print(f\"    Switch state set to: {switch.get_state_description()}\")\n            return switch\n        else:\n            self._debug_print(f\"    No valid connections found\")\n            return None\n\n    def _smart_split_infrastructure(self, infra_str: str) -> List[str]:\n        \"\"\"\n        Intelligently split infrastructure string, respecting parentheses.\n\n        For example: \"STATION; SWITCH (15-16; 1-16); UNDERGROUND\"\n        Should split into: [\"STATION\", \"SWITCH (15-16; 1-16)\", \"UNDERGROUND\"]\n        Not: [\"STATION\", \"SWITCH (15-16\", \"1-16)\", \"UNDERGROUND\"]\n        \"\"\"\n        items = []\n        current_item = \"\"\n        paren_depth = 0\n\n        for char in infra_str:\n            if char == '(':\n                paren_depth += 1\n                current_item += char\n            elif char == ')':\n                paren_depth -= 1\n                current_item += char\n            elif char == ';' and paren_depth == 0:\n                # Only split on semicolon if we're not inside parentheses\n                if current_item.strip():\n                    items.append(current_item.strip())\n                current_item = \"\"\n            else:\n                current_item += char\n\n        # Add the last item\n        if current_item.strip():\n            items.append(current_item.strip())\n\n        return items\n\n    def _parse_block_direction(self, direction_str: str) -> BlockDirection:\n        \"\"\"\n        Parse block direction string from Excel data.\n\n        Args:\n            direction_str: Direction string from Excel (\"forward\", \"backward\", \"bidirectional\", etc.)\n\n        Returns:\n            BlockDirection enum value\n        \"\"\"\n        if pd.isna(direction_str) or not direction_str:\n            self._debug_print(f\"    No direction specified, defaulting to BIDIRECTIONAL\")\n            return BlockDirection.BIDIRECTIONAL\n\n        direction_clean = str(direction_str).strip().upper()\n        self._debug_print(f\"    Parsing direction: '{direction_str}' -> '{direction_clean}'\")\n\n        # Handle various ways direction might be specified\n        if direction_clean in [\"FORWARD\", \"FWD\", \"F\", \"→\", \"FORWARDS\"]:\n            return BlockDirection.FORWARD\n        elif direction_clean in [\"BACKWARD\", \"BACKWARDS\", \"BWD\", \"B\", \"←\", \"REVERSE\", \"REV\"]:\n            return BlockDirection.BACKWARD\n        elif direction_clean in [\"BIDIRECTIONAL\", \"BOTH\", \"BI\", \"BIDIR\", \"↔\", \"BOTH WAYS\", \"EITHER\"]:\n            return BlockDirection.BIDIRECTIONAL\n        else:\n            # Log unknown direction and default to bidirectional\n            self._debug_print(f\"    Unknown direction '{direction_str}', defaulting to BIDIRECTIONAL\")\n            return BlockDirection.BIDIRECTIONAL\n\n    def _normalize_platform_side(self, side_str: str) -> str:\n        \"\"\"\n        Normalize platform side strings.\n        Left, Right, or Both all mean the platform serves both sides.\n        \"\"\"\n        if pd.isna(side_str) or not side_str:\n            return \"Both\"\n\n        side_upper = str(side_str).strip().upper()\n\n        # All platform configurations mean trains can be served\n        if side_upper in [\"LEFT\", \"RIGHT\", \"BOTH\", \"L\", \"R\", \"B\"]:\n            return \"Both\"\n\n        return \"Both\"  # Default to Both\n\n    def _parse_infrastructure(self, infra_str: str, block_num: int, line: str) -> Tuple[\n        bool, Optional[Station], bool, Optional[Switch], bool, bool]:\n        \"\"\"\n        Parse infrastructure string to identify stations, switches, etc.\n\n        Format:\n        - STATION; STATION_NAME - station with given name\n        - Switch (5-6) - simple switch\n        - Switch (5-6; 5-11) - multi-destination switch\n        - SWITCH TO/FROM YARD (75-yard) - bidirectional yard switch\n        - SWITCH TO YARD (57-yard) - one-way to yard\n        - SWITCH FROM YARD (Yard-63) - one-way from yard\n        - UNDERGROUND - underground section\n        - RAILWAY CROSSING - railway crossing\n        - Multiple items separated by semicolons (respecting parentheses)\n\n        Returns: (has_station, station, has_switch, switch, has_crossing, is_underground)\n        \"\"\"\n\n        self._debug_print(f\"Parsing infrastructure for {line} Line Block {block_num}: '{infra_str}'\")\n\n        if pd.isna(infra_str) or infra_str is None:\n            self._debug_print(f\"  -> No infrastructure data (NaN/None)\")\n            return False, None, False, None, False, False\n\n        infra_str = str(infra_str).strip()\n\n        has_station = False\n        station = None\n        has_switch = False\n        switch = None\n        has_crossing = False\n        is_underground = False\n\n        # Use smart splitting that respects parentheses\n        items = self._smart_split_infrastructure(infra_str)\n        self._debug_print(f\"  Smart split result: {items}\")\n\n        for item in items:\n            if not item:  # Skip empty items\n                continue\n\n            item_upper = item.upper()\n            self._debug_print(f\"  Processing item: '{item}'\")\n\n            # Check for SWITCH with various formats (check this FIRST before station)\n            if 'SWITCH' in item_upper:\n                has_switch = True\n                switch = self._parse_switch_string(item, block_num)\n                if switch:\n                    self._debug_print(f\"  -> Successfully parsed switch: {switch}\")\n                else:\n                    # Create default switch if parsing failed\n                    self._debug_print(f\"  -> Switch parsing failed, creating default switch\")\n                    default_conn = SwitchConnection(\n                        from_block=block_num,\n                        to_block=block_num + 1,\n                        direction=SwitchDirection.BIDIRECTIONAL\n                    )\n                    switch = Switch(connections=[default_conn], switch_type=\"STANDARD\")\n                    switch.set_normal_state_from_blocks()\n\n            # Check for STATION\n            elif item_upper.startswith('STATION'):\n                has_station = True\n                # Extract station name - it should be after \"STATION\" or after a semicolon/space\n                if 'STATION' in item:\n                    # Split by STATION and take what's after it\n                    parts = item.split('STATION', 1)\n                    if len(parts) > 1 and parts[1].strip():\n                        station_name = parts[1].strip()\n                        # Remove any leading punctuation\n                        if station_name and station_name[0] in [';', ':', ' ']:\n                            station_name = station_name[1:].strip()\n                        if station_name:\n                            self.station_counter += 1\n                            station = Station(name=station_name, side=\"Both\", station_id=self.station_counter)\n                            self._debug_print(f\"  -> Found station: '{station_name}' (ID: {self.station_counter})\")\n                        else:\n                            # No name provided, use default\n                            self.station_counter += 1\n                            station = Station(name=f\"Station {block_num}\", side=\"Both\", station_id=self.station_counter)\n                            self._debug_print(f\"  -> Station with no name, using default (ID: {self.station_counter})\")\n                    else:\n                        # Check if there's another item that might be the station name\n                        # Look at the next item in the list\n                        try:\n                            idx = items.index(item)\n                            if idx + 1 < len(items) and items[idx + 1].strip():\n                                # Next item might be the station name\n                                next_item = items[idx + 1].strip()\n                                if not any(keyword in next_item.upper() for keyword in ['SWITCH', 'UNDERGROUND', 'CROSSING']):\n                                    self.station_counter += 1\n                                    station = Station(name=next_item, side=\"Both\", station_id=self.station_counter)\n                                    self._debug_print(f\"  -> Found station name in next item: '{next_item}' (ID: {self.station_counter})\")\n                                    # Mark this item as processed\n                                    items[idx + 1] = \"\"\n                                else:\n                                    self.station_counter += 1\n                                    station = Station(name=f\"Station {block_num}\", side=\"Both\", station_id=self.station_counter)\n                                    self._debug_print(f\"  -> Station with no name, using default (ID: {self.station_counter})\")\n                            else:\n                                self.station_counter += 1\n                                station = Station(name=f\"Station {block_num}\", side=\"Both\", station_id=self.station_counter)\n                                self._debug_print(f\"  -> Station with no name, using default (ID: {self.station_counter})\")\n                        except ValueError:\n                            self.station_counter += 1\n                            station = Station(name=f\"Station {block_num}\", side=\"Both\", station_id=self.station_counter)\n                            self._debug_print(f\"  -> Station with no name, using default (ID: {self.station_counter})\")\n\n            # Check for UNDERGROUND\n            elif 'UNDERGROUND' in item_upper:\n                is_underground = True\n                self._debug_print(f\"  -> Found underground section\")\n\n            # Check for RAILWAY CROSSING\n            elif any(crossing_term in item_upper for crossing_term in ['CROSSING', 'RAILWAY CROSSING', 'X-ING', 'XING']):\n                has_crossing = True\n                self._debug_print(f\"  -> Found railway crossing\")\n\n            # If none of the above keywords, it might be a station name without STATION prefix\n            elif item and not any(keyword in item_upper for keyword in ['SWITCH', 'UNDERGROUND', 'CROSSING']):\n                # This could be a standalone station name\n                # But be careful - don't treat fragments like \"1-16)\" as station names\n                if not has_station and not re.search(r'\\d+-\\d+\\)', item):  # Avoid switch fragments\n                    has_station = True\n                    self.station_counter += 1\n                    station = Station(name=item, side=\"Both\", station_id=self.station_counter)\n                    self._debug_print(f\"  -> Treating standalone text as station: '{item}' (ID: {self.station_counter})\")\n                else:\n                    self._debug_print(f\"  -> Ignoring potential switch fragment: '{item}'\")\n\n        self._debug_print(f\"  -> Final result: station={has_station}, switch={has_switch}, crossing={has_crossing}, underground={is_underground}\")\n        return has_station, station, has_switch, switch, has_crossing, is_underground\n\n    def _load_track_data(self):\n        \"\"\"Load track data from the Excel file\"\"\"\n        try:\n            # Read the Excel file\n            self._debug_print(f\"Loading track data from: {self.file_path}\")\n            excel_data = pd.ExcelFile(self.file_path)\n            self._debug_print(f\"Available sheets: {excel_data.sheet_names}\")\n\n            # Process each selected line\n            for line_name in self.selected_lines:\n                sheet_name = f\"{line_name} Line\"\n                if sheet_name not in excel_data.sheet_names:\n                    print(f\"Warning: {sheet_name} not found in Excel file\")\n                    continue\n\n                self._debug_print(f\"\\n=== Processing {sheet_name} ===\")\n\n                # Read the sheet\n                df = pd.read_excel(excel_data, sheet_name)\n                self._debug_print(f\"Sheet columns: {list(df.columns)}\")\n                self._debug_print(f\"Sheet shape: {df.shape}\")\n\n                # Show first few rows for debugging\n                if DEBUG_PARSING and len(df) > 0:\n                    self._debug_print(\"First few rows:\")\n                    for i in range(min(5, len(df))):\n                        row = df.iloc[i]\n                        self._debug_print(f\"  Row {i}: Block={row.get('Block Number')}, Section={row.get('Section')}, Infrastructure='{row.get('Infrastructure')}'\")\n\n                block_count = 0\n                station_count = 0\n                switch_count = 0\n                crossing_count = 0\n\n                # Process each row\n                for idx, row in df.iterrows():\n                    # More robust validation for valid blocks\n                    block_number_raw = row.get('Block Number')\n\n                    # Skip rows with no block number or invalid block numbers\n                    if pd.isna(block_number_raw):\n                        self._debug_print(f\"  Skipping row {idx}: Block Number is NaN\")\n                        continue\n\n                    # Try to convert to integer\n                    try:\n                        block_num = int(float(block_number_raw))  # Handle potential float values\n                    except (ValueError, TypeError):\n                        self._debug_print(f\"  Skipping row {idx}: Block Number '{block_number_raw}' cannot be converted to integer\")\n                        continue\n\n                    # Skip invalid block numbers (0 or negative)\n                    if block_num <= 0:\n                        self._debug_print(f\"  Skipping row {idx}: Block Number {block_num} is not valid (must be > 0)\")\n                        continue\n\n                    # Additional validation - check if this looks like a real data row\n                    section = row.get('Section', '')\n                    length = row.get('Block Length (m)', 0)\n\n                    # Skip rows that don't have basic required data\n                    if pd.isna(section) and (pd.isna(length) or length == 0):\n                        self._debug_print(f\"  Skipping row {idx}: Block {block_num} missing essential data (section and length)\")\n                        continue\n\n                    self._debug_print(f\"  Processing valid block {block_num} at row {idx}\")\n\n                    # Parse infrastructure\n                    has_station, station, has_switch, switch, has_crossing, is_underground = \\\n                        self._parse_infrastructure(row.get('Infrastructure'), block_num, line_name)\n\n                    # Parse block direction\n                    block_direction = self._parse_block_direction(row.get('Line Direction'))\n\n                    # Handle station side if specified\n                    if has_station and station and 'Station Side' in row and not pd.isna(row['Station Side']):\n                        station.side = self._normalize_platform_side(row['Station Side'])\n                        self._debug_print(f\"  -> Updated station side to: {station.side}\")\n\n                    # Create track block with safer data extraction\n                    try:\n                        block = TrackBlock(\n                            line=line_name,\n                            section=str(row.get('Section', '')).strip(),\n                            block_number=block_num,\n                            length_m=float(row.get('Block Length (m)', 0)),\n                            grade_percent=float(row.get('Block Grade (%)', 0)),\n                            speed_limit_kmh=float(row.get('Speed Limit (Km/Hr)', 0)),\n                            elevation_m=float(row.get('ELEVATION (M)', 0)),\n                            direction=block_direction,\n                            has_station=has_station,\n                            station=station,\n                            has_switch=has_switch,\n                            switch=switch,\n                            has_crossing=has_crossing,\n                            is_underground=is_underground\n                        )\n                    except (ValueError, TypeError) as e:\n                        self._debug_print(f\"  Error creating block {block_num}: {e}\")\n                        continue\n\n                    # Calculate minimum traversal time\n                    if block.speed_limit_kmh > 0 and block.length_m > 0:\n                        # Convert km/hr to m/s, then calculate time\n                        speed_ms = block.speed_limit_kmh * 1000 / 3600\n                        block.min_traversal_time_seconds = block.length_m / speed_ms\n                        self._debug_print(f\"  Block {block_num}: {block.length_m}m at {block.speed_limit_kmh} km/hr = {block.min_traversal_time_seconds:.1f}s\")\n                    else:\n                        block.min_traversal_time_seconds = 0.0\n                        self._debug_print(f\"  Block {block_num}: No valid speed/length for traversal time calculation\")\n\n                    # Check for duplicate blocks\n                    existing_blocks = [b.block_number for b in self.lines[line_name]]\n                    if block_num in existing_blocks:\n                        self._debug_print(f\"  WARNING: Duplicate block number {block_num} found! Skipping.\")\n                        continue\n\n                    # Add to line data\n                    self.lines[line_name].append(block)\n                    block_count += 1\n\n                    if has_station:\n                        station_count += 1\n                    if has_switch:\n                        switch_count += 1\n                    if has_crossing:\n                        crossing_count += 1\n\n                    # Track sections\n                    if block.section and block.section not in self.sections[line_name]:\n                        self.sections[line_name][block.section] = []\n                    if block.section:\n                        self.sections[line_name][block.section].append(block.block_number)\n\n                    # Debug output for significant blocks\n                    if has_station or has_switch or has_crossing:\n                        self._debug_print(f\"  Block {block_num}: {block.get_infrastructure_description()}\")\n\n                self._debug_print(f\"{line_name} Line Summary: {block_count} blocks, {station_count} stations, {switch_count} switches, {crossing_count} crossings\")\n\n            print(f\"Successfully loaded track data:\")\n            for line, blocks in self.lines.items():\n                stations = sum(1 for b in blocks if b.has_station)\n                switches = sum(1 for b in blocks if b.has_switch)\n                crossings = sum(1 for b in blocks if b.has_crossing)\n                underground = sum(1 for b in blocks if b.is_underground)\n                print(f\"  {line} Line: {len(blocks)} blocks, {stations} stations, {switches} switches, {crossings} crossings, {underground} underground\")\n\n            # Debug: Show all stations found\n            if DEBUG_PARSING:\n                self._debug_print(\"\\n=== ALL STATIONS FOUND ===\")\n                for line_name in self.selected_lines:\n                    stations = self.get_all_stations(line_name)\n                    self._debug_print(f\"{line_name} Line stations ({len(stations)} total):\")\n                    for station in stations:\n                        self._debug_print(f\"  - Block {station['block_number']}: {station['station_name']} ({station['platform_side']})\")\n\n        except Exception as e:\n            print(f\"Error loading track data: {e}\")\n            import traceback\n            traceback.print_exc()\n            raise\n\n    # === Methods for Dispatcher Interface ===\n\n    def get_all_stations(self, line: Optional[str] = None) -> List[Dict]:\n        \"\"\"\n        Get all stations for dispatcher display.\n        Returns list of station info with block numbers for easy routing.\n        \"\"\"\n        stations = []\n        lines_to_check = [line] if line else self.selected_lines\n\n        for line_name in lines_to_check:\n            for block in self.lines.get(line_name, []):\n                if block.has_station and block.station:\n                    stations.append({\n                        \"line\": line_name,\n                        \"block_number\": block.block_number,\n                        \"station_id\": block.station.station_id,\n                        \"station_name\": block.station.name,\n                        \"platform_side\": block.station.side,\n                        \"section\": block.section\n                    })\n\n        return sorted(stations, key=lambda x: (x[\"line\"], x[\"block_number\"]))\n\n    def get_all_switches(self, line: Optional[str] = None) -> List[Dict]:\n        \"\"\"\n        Get all switches for dispatcher routing decisions.\n        Returns switch info in easy-to-understand format.\n        \"\"\"\n        switches = []\n        lines_to_check = [line] if line else self.selected_lines\n\n        for line_name in lines_to_check:\n            for block in self.lines.get(line_name, []):\n                if block.has_switch and block.switch:\n                    # Get all possible destinations from this switch\n                    all_destinations = set()\n                    for conn in block.switch.connections:\n                        all_destinations.add(conn.to_block)\n                        if conn.direction == SwitchDirection.BIDIRECTIONAL:\n                            all_destinations.add(conn.from_block)\n\n                    switches.append({\n                        \"line\": line_name,\n                        \"block_number\": block.block_number,\n                        \"switch_type\": block.switch.switch_type,\n                        \"normal_state\": block.switch.normal_state,\n                        \"current_state\": block.switch.current_state,\n                        \"state_description\": block.switch.get_state_description(),\n                        \"connections\": [\n                            {\n                                \"from_block\": conn.from_block,\n                                \"to_block\": conn.to_block,\n                                \"direction\": conn.direction.value,\n                                \"description\": str(conn)\n                            }\n                            for conn in block.switch.connections\n                        ],\n                        \"all_destinations\": list(all_destinations),\n                        \"section\": block.section,\n                        \"description\": str(block.switch)\n                    })\n\n        return switches\n\n    def get_route_options(self, line: str, from_block: int, to_block: int) -> List[List[int]]:\n        \"\"\"\n        Get possible routes between two blocks.\n        Useful for dispatcher routing interface.\n\n        Returns:\n            List of possible routes (each route is a list of block numbers)\n        \"\"\"\n        # Simple implementation - can be enhanced with graph algorithms\n        if from_block == to_block:\n            return [[from_block]]\n\n        # For now, return direct route if blocks are sequential\n        # This should be enhanced with proper pathfinding for switches\n        blocks = self.lines.get(line, [])\n        block_nums = [b.block_number for b in blocks]\n\n        if from_block in block_nums and to_block in block_nums:\n            start_idx = block_nums.index(from_block)\n            end_idx = block_nums.index(to_block)\n\n            if start_idx < end_idx:\n                route = block_nums[start_idx:end_idx + 1]\n            else:\n                route = block_nums[end_idx:start_idx + 1][::-1]\n\n            return [route]\n\n        return []\n\n    def get_block_info(self, line: str, block_number: int) -> Optional[TrackBlock]:\n        \"\"\"Get detailed information about a specific block\"\"\"\n        for block in self.lines.get(line, []):\n            if block.block_number == block_number:\n                return block\n        return None\n\n    def get_maintenance_zones(self, line: str) -> Dict[str, List[int]]:\n        \"\"\"\n        Get blocks organized by section for maintenance planning.\n        Sections can be closed for maintenance independently.\n        \"\"\"\n        return self.sections.get(line, {})\n\n    def calculate_journey_time(self, line: str, route: List[int]) -> float:\n        \"\"\"\n        Calculate estimated journey time for a route at speed limits.\n        Returns time in seconds.\n        \"\"\"\n        total_time = 0\n        for block_num in route:\n            block = self.get_block_info(line, block_num)\n            if block:\n                total_time += block.min_traversal_time_seconds\n        return total_time\n\n    def export_for_display(self, line: str) -> List[Dict]:\n        \"\"\"\n        Export track data in format suitable for graphical display.\n        Includes all info needed for dispatcher interface.\n        \"\"\"\n        display_data = []\n        for block in self.lines.get(line, []):\n            display_data.append({\n                \"block_number\": block.block_number,\n                \"section\": block.section,\n                \"length_m\": block.length_m,\n                \"speed_limit_kmh\": block.speed_limit_kmh,\n                \"grade_percent\": block.grade_percent,\n                \"elevation_m\": block.elevation_m,\n                \"direction\": block.direction.value,\n                \"direction_description\": block.get_direction_description(),\n                \"min_traversal_time_seconds\": block.min_traversal_time_seconds,\n                \"infrastructure\": block.get_infrastructure_description(),\n                \"has_station\": block.has_station,\n                \"has_switch\": block.has_switch,\n                \"has_crossing\": block.has_crossing,\n                \"is_underground\": block.is_underground\n            })\n        return display_data\n\n    def get_block_traversal_time(self, line: str, block_number: int) -> float:\n        \"\"\"\n        Get the minimum traversal time for a specific block.\n        Useful for dispatcher timing calculations.\n\n        Returns:\n            Minimum traversal time in seconds, or 0.0 if block not found\n        \"\"\"\n        block = self.get_block_info(line, block_number)\n        return block.min_traversal_time_seconds if block else 0.0\n\n    def validate_route_direction(self, line: str, route: List[int]) -> Tuple[bool, List[str]]:\n        \"\"\"\n        Validate if a route is allowed based on block directions.\n\n        Args:\n            line: Line name (\"Blue\", \"Red\", \"Green\")\n            route: List of block numbers in order\n\n        Returns:\n            Tuple of (is_valid, list_of_violations)\n        \"\"\"\n        violations = []\n\n        if len(route) < 2:\n            return True, []  # Single block or empty route is always valid\n\n        for i in range(len(route) - 1):\n            current_block_num = route[i]\n            next_block_num = route[i + 1]\n\n            current_block = self.get_block_info(line, current_block_num)\n            if not current_block:\n                violations.append(f\"Block {current_block_num} not found\")\n                continue\n\n            if not current_block.can_move_to_block(next_block_num):\n                violations.append(\n                    f\"Block {current_block_num} ({current_block.get_direction_description()}) \"\n                    f\"cannot move to Block {next_block_num}\"\n                )\n\n        return len(violations) == 0, violations\n\n    def get_valid_next_blocks(self, line: str, current_block_number: int) -> List[int]:\n        \"\"\"\n        Get list of valid next blocks from current block based on direction restrictions.\n\n        Args:\n            line: Line name\n            current_block_number: Current block number\n\n        Returns:\n            List of valid next block numbers\n        \"\"\"\n        current_block = self.get_block_info(line, current_block_number)\n        if not current_block:\n            return []\n\n        valid_blocks = []\n        all_blocks = [b.block_number for b in self.lines.get(line, [])]\n\n        for block_num in all_blocks:\n            if block_num != current_block_number and current_block.can_move_to_block(block_num):\n                # Additional check: is this block actually adjacent or reachable?\n                # For now, just check if it's numerically adjacent\n                if abs(block_num - current_block_number) == 1:\n                    valid_blocks.append(block_num)\n\n        return sorted(valid_blocks)\n\n    def get_directional_summary(self, line: Optional[str] = None) -> Dict[str, Dict[str, int]]:\n        \"\"\"\n        Get summary of block directions for dispatcher overview.\n\n        Returns:\n            Dictionary with direction counts per line\n        \"\"\"\n        summary = {}\n        lines_to_check = [line] if line else self.selected_lines\n\n        for line_name in lines_to_check:\n            summary[line_name] = {\n                \"FORWARD\": 0,\n                \"BACKWARD\": 0,\n                \"BIDIRECTIONAL\": 0,\n                \"TOTAL\": 0\n            }\n\n            for block in self.lines.get(line_name, []):\n                summary[line_name][block.direction.value] += 1\n                summary[line_name][\"TOTAL\"] += 1\n\n        return summary\n\n    def get_yard_connections(self, line: Optional[str] = None) -> List[Dict]:\n        \"\"\"\n        Get all yard connections for dispatcher interface.\n        Returns information about switches connecting to/from yard.\n        \"\"\"\n        yard_connections = []\n        lines_to_check = [line] if line else self.selected_lines\n\n        for line_name in lines_to_check:\n            for block in self.lines.get(line_name, []):\n                if block.has_switch and block.switch:\n                    for conn in block.switch.connections:\n                        if conn.from_block == \"yard\" or conn.to_block == \"yard\":\n                            yard_connections.append({\n                                \"line\": line_name,\n                                \"block_number\": block.block_number,\n                                \"connection\": str(conn),\n                                \"direction\": conn.direction.value,\n                                \"switch_type\": block.switch.switch_type,\n                                \"from_block\": conn.from_block,\n                                \"to_block\": conn.to_block\n                            })\n\n        return yard_connections\n\n    # === Utility Functions for Module Integration ===\n\n    def get_block_by_number(self, block_number: int, line: Optional[str] = None) -> Optional[TrackBlock]:\n        \"\"\"\n        Get detailed information about a specific block by its number.\n        \n        Args:\n            block_number: The block number to find\n            line: Optional line to search in. If None, searches all lines.\n            \n        Returns:\n            TrackBlock object if found, None otherwise\n        \"\"\"\n        lines_to_check = [line] if line else self.selected_lines\n        \n        for line_name in lines_to_check:\n            for block in self.lines.get(line_name, []):\n                if block.block_number == block_number:\n                    return block\n        return None\n\n    def get_station_by_id(self, station_id: int) -> Optional[Dict]:\n        \"\"\"\n        Get station information by station ID.\n        \n        Args:\n            station_id: The unique station ID\n            \n        Returns:\n            Dictionary with station info or None if not found\n        \"\"\"\n        for line_name in self.selected_lines:\n            for block in self.lines.get(line_name, []):\n                if block.has_station and block.station and block.station.station_id == station_id:\n                    return {\n                        \"station_id\": block.station.station_id,\n                        \"name\": block.station.name,\n                        \"platform_side\": block.station.side,\n                        \"line\": line_name,\n                        \"block_number\": block.block_number,\n                        \"section\": block.section\n                    }\n        return None\n\n    def get_line_for_station(self, station_id: int) -> Optional[str]:\n        \"\"\"\n        Get the line name for a given station ID.\n        \n        Args:\n            station_id: The unique station ID\n            \n        Returns:\n            Line name (\"Blue\", \"Red\", \"Green\") or None if not found\n        \"\"\"\n        station_info = self.get_station_by_id(station_id)\n        return station_info[\"line\"] if station_info else None\n\n    def get_switch_by_block(self, block_number: int, line: Optional[str] = None) -> Optional[Dict]:\n        \"\"\"\n        Get switch information for a specific block.\n        \n        Args:\n            block_number: The block number to check\n            line: Optional line to search in. If None, searches all lines.\n            \n        Returns:\n            Dictionary with switch info or None if no switch found\n        \"\"\"\n        block = self.get_block_by_number(block_number, line)\n        if block and block.has_switch and block.switch:\n            return {\n                \"block_number\": block.block_number,\n                \"line\": block.line,\n                \"switch_type\": block.switch.switch_type,\n                \"normal_state\": block.switch.normal_state,\n                \"current_state\": block.switch.current_state,\n                \"state_description\": block.switch.get_state_description(),\n                \"connections\": [\n                    {\n                        \"from_block\": conn.from_block,\n                        \"to_block\": conn.to_block,\n                        \"direction\": conn.direction.value,\n                        \"description\": str(conn)\n                    }\n                    for conn in block.switch.connections\n                ],\n                \"description\": str(block.switch)\n            }\n        return None\n\n    def get_block_infrastructure_summary(self, block_number: int, line: Optional[str] = None) -> Dict:\n        \"\"\"\n        Get a summary of infrastructure on a specific block.\n        \n        Args:\n            block_number: The block number to check\n            line: Optional line to search in. If None, searches all lines.\n            \n        Returns:\n            Dictionary with infrastructure summary\n        \"\"\"\n        block = self.get_block_by_number(block_number, line)\n        if not block:\n            return {\n                \"block_found\": False,\n                \"block_number\": block_number,\n                \"line\": line,\n                \"error\": \"Block not found\"\n            }\n        \n        return {\n            \"block_found\": True,\n            \"block_number\": block.block_number,\n            \"line\": block.line,\n            \"section\": block.section,\n            \"has_station\": block.has_station,\n            \"station_info\": {\n                \"station_id\": block.station.station_id,\n                \"name\": block.station.name,\n                \"platform_side\": block.station.side\n            } if block.has_station and block.station else None,\n            \"has_switch\": block.has_switch,\n            \"switch_info\": {\n                \"switch_type\": block.switch.switch_type,\n                \"normal_state\": block.switch.normal_state,\n                \"current_state\": block.switch.current_state,\n                \"state_description\": block.switch.get_state_description()\n            } if block.has_switch and block.switch else None,\n            \"has_crossing\": block.has_crossing,\n            \"is_underground\": block.is_underground,\n            \"speed_limit_kmh\": block.speed_limit_kmh,\n            \"length_m\": block.length_m,\n            \"grade_percent\": block.grade_percent,\n            \"elevation_m\": block.elevation_m,\n            \"direction\": block.direction.value,\n            \"direction_description\": block.get_direction_description(),\n            \"min_traversal_time_seconds\": block.min_traversal_time_seconds,\n            \"infrastructure_description\": block.get_infrastructure_description()\n        }\n\n    def is_block_station(self, block_number: int, line: Optional[str] = None) -> bool:\n        \"\"\"\n        Check if a block has a station.\n        \n        Args:\n            block_number: The block number to check\n            line: Optional line to search in. If None, searches all lines.\n            \n        Returns:\n            True if block has a station, False otherwise\n        \"\"\"\n        block = self.get_block_by_number(block_number, line)\n        return block.has_station if block else False\n\n    def is_block_switch(self, block_number: int, line: Optional[str] = None) -> bool:\n        \"\"\"\n        Check if a block has a switch.\n        \n        Args:\n            block_number: The block number to check\n            line: Optional line to search in. If None, searches all lines.\n            \n        Returns:\n            True if block has a switch, False otherwise\n        \"\"\"\n        block = self.get_block_by_number(block_number, line)\n        return block.has_switch if block else False\n\n    def get_block_speed_limit(self, block_number: int, line: Optional[str] = None) -> Optional[float]:\n        \"\"\"\n        Get the speed limit for a specific block.\n        \n        Args:\n            block_number: The block number to check\n            line: Optional line to search in. If None, searches all lines.\n            \n        Returns:\n            Speed limit in km/h or None if block not found\n        \"\"\"\n        block = self.get_block_by_number(block_number, line)\n        return block.speed_limit_kmh if block else None\n\n    def get_block_length(self, block_number: int, line: Optional[str] = None) -> Optional[float]:\n        \"\"\"\n        Get the length of a specific block.\n        \n        Args:\n            block_number: The block number to check\n            line: Optional line to search in. If None, searches all lines.\n            \n        Returns:\n            Block length in meters or None if block not found\n        \"\"\"\n        block = self.get_block_by_number(block_number, line)\n        return block.length_m if block else None\n\n    def get_adjacent_blocks(self, block_number: int, line: str) -> List[int]:\n        \"\"\"\n        Get blocks adjacent to the given block (numerically adjacent).\n        \n        Args:\n            block_number: The block number to check\n            line: The line to search in\n            \n        Returns:\n            List of adjacent block numbers\n        \"\"\"\n        adjacent = []\n        all_blocks = [b.block_number for b in self.lines.get(line, [])]\n        \n        # Check for numerically adjacent blocks\n        if (block_number - 1) in all_blocks:\n            adjacent.append(block_number - 1)\n        if (block_number + 1) in all_blocks:\n            adjacent.append(block_number + 1)\n            \n        return adjacent\n\n\n    def get_stations_on_line(self, line: str) -> List[Dict]:\n        \"\"\"\n        Get all stations on a specific line, sorted by block number.\n        \n        Args:\n            line: The line name (\"Blue\", \"Red\", \"Green\")\n            \n        Returns:\n            List of station dictionaries\n        \"\"\"\n        stations = []\n        for block in sorted(self.lines.get(line, []), key=lambda b: b.block_number):\n            if block.has_station and block.station:\n                stations.append({\n                    \"station_id\": block.station.station_id,\n                    \"name\": block.station.name,\n                    \"platform_side\": block.station.side,\n                    \"block_number\": block.block_number,\n                    \"line\": line,\n                    \"section\": block.section\n                })\n        return stations\n\n    def get_switches_on_line(self, line: str) -> List[Dict]:\n        \"\"\"\n        Get all switches on a specific line, sorted by block number.\n        \n        Args:\n            line: The line name (\"Blue\", \"Red\", \"Green\")\n            \n        Returns:\n            List of switch dictionaries\n        \"\"\"\n        switches = []\n        for block in sorted(self.lines.get(line, []), key=lambda b: b.block_number):\n            if block.has_switch and block.switch:\n                switches.append({\n                    \"block_number\": block.block_number,\n                    \"line\": line,\n                    \"switch_type\": block.switch.switch_type,\n                    \"normal_state\": block.switch.normal_state,\n                    \"current_state\": block.switch.current_state,\n                    \"state_description\": block.switch.get_state_description(),\n                    \"connections\": [\n                        {\n                            \"from_block\": conn.from_block,\n                            \"to_block\": conn.to_block,\n                            \"direction\": conn.direction.value,\n                            \"description\": str(conn)\n                        }\n                        for conn in block.switch.connections\n                    ],\n                    \"description\": str(block.switch)\n                })\n        return switches\n\n\n    def get_line_summary(self, line: str) -> Dict:\n        \"\"\"\n        Get a comprehensive summary of a line.\n        \n        Args:\n            line: The line name (\"Blue\", \"Red\", \"Green\")\n            \n        Returns:\n            Dictionary with line summary information\n        \"\"\"\n        blocks = self.lines.get(line, [])\n        \n        if not blocks:\n            return {\"line\": line, \"error\": \"Line not found or has no blocks\"}\n        \n        stations = [b for b in blocks if b.has_station]\n        switches = [b for b in blocks if b.has_switch]\n        crossings = [b for b in blocks if b.has_crossing]\n        underground = [b for b in blocks if b.is_underground]\n        \n        return {\n            \"line\": line,\n            \"total_blocks\": len(blocks),\n            \"block_range\": {\n                \"min\": min(b.block_number for b in blocks),\n                \"max\": max(b.block_number for b in blocks)\n            },\n            \"total_length_m\": sum(b.length_m for b in blocks),\n            \"stations\": {\n                \"count\": len(stations),\n                \"station_ids\": [b.station.station_id for b in stations if b.station],\n                \"names\": [b.station.name for b in stations if b.station]\n            },\n            \"switches\": {\n                \"count\": len(switches),\n                \"blocks\": [b.block_number for b in switches]\n            },\n            \"crossings\": {\n                \"count\": len(crossings),\n                \"blocks\": [b.block_number for b in crossings]\n            },\n            \"underground\": {\n                \"count\": len(underground),\n                \"blocks\": [b.block_number for b in underground]\n            },\n            \"sections\": list(self.sections.get(line, {}).keys())\n        }\n\n\n# === Example Usage ===\nif __name__ == \"__main__\":\n    # Initialize the track layout reader\n    reader = TrackLayoutReader(\"Track Layout & Vehicle Data vF2.xlsx\")
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Track_Reader/track_reader.py b/Track_Reader/track_reader.py
--- a/Track_Reader/track_reader.py	(revision 58821640d3fc1243a45beca7e2f7ac46d5ad7247)
+++ b/Track_Reader/track_reader.py	(date 1752437897590)
@@ -13,7 +13,7 @@
 import json
 import re
 from typing import Dict, List, Optional, Tuple, Union
-from dataclasses import dataclass, asdict
+from dataclasses import dataclass, asdict, field
 from enum import Enum
 
 
@@ -162,6 +162,10 @@
 
     # Calculated fields - minimum time to traverse at speed limit
     min_traversal_time_seconds: float = 0.0  # Minimum time to traverse this block
+    
+    # Connected blocks data - NEW: from Excel "Connected Blocks" column
+    connected_blocks: List[int] = field(default_factory=list)  # Block numbers this block connects to
+    has_yard_connection: bool = False  # True if block connects to yard (-1)
 
     def can_move_to_block(self, target_block_number: int) -> bool:
         """
@@ -205,6 +209,36 @@
 
         return "; ".join(items) if items else "No special infrastructure"
 
+    def get_connected_blocks(self) -> List[int]:
+        """
+        Get list of block numbers this block connects to.
+        
+        Returns:
+            List of connected block numbers (excludes yard connections)
+        """
+        return [block_num for block_num in self.connected_blocks if block_num != -1]
+
+    def is_connected_to(self, block_number: int) -> bool:
+        """
+        Check if this block is connected to the specified block number.
+        
+        Args:
+            block_number: Block number to check connection to
+            
+        Returns:
+            True if connected, False otherwise
+        """
+        return block_number in self.connected_blocks
+
+    def leads_to_yard(self) -> bool:
+        """
+        Check if this block has a connection to the yard.
+        
+        Returns:
+            True if block connects to yard (-1), False otherwise
+        """
+        return self.has_yard_connection
+
 
 class TrackLayoutReader:
     """
@@ -481,6 +515,55 @@
 
         return "Both"  # Default to Both
 
+    def _parse_connected_blocks(self, connected_str) -> Tuple[List[int], bool]:
+        """
+        Parse connected blocks string from Excel data.
+        
+        Args:
+            connected_str: Connected blocks data from Excel (int, string, or NaN)
+            
+        Returns:
+            Tuple of (connected_blocks_list, has_yard_connection)
+        """
+        # Handle NaN/None values
+        if pd.isna(connected_str) or connected_str is None:
+            self._debug_print(f"    No connected blocks data (NaN/None)")
+            return [], False
+        
+        connected_blocks = []
+        has_yard = False
+        
+        # Handle single integer (Excel might read as int)
+        if isinstance(connected_str, (int, float)):
+            block_num = int(connected_str)
+            if block_num == -1:
+                has_yard = True
+            else:
+                connected_blocks.append(block_num)
+            self._debug_print(f"    Single connection: {block_num}")
+        
+        # Handle comma-separated string
+        elif isinstance(connected_str, str):
+            # Split by comma and clean up
+            parts = [part.strip() for part in connected_str.split(',')]
+            for part in parts:
+                if part:
+                    try:
+                        block_num = int(part)
+                        if block_num == -1:
+                            has_yard = True
+                        else:
+                            connected_blocks.append(block_num)
+                    except ValueError:
+                        self._debug_print(f"    Could not parse connected block: '{part}'")
+            
+            self._debug_print(f"    Multiple connections: {connected_blocks}, yard: {has_yard}")
+        
+        else:
+            self._debug_print(f"    Unknown connected blocks format: {type(connected_str)} - {connected_str}")
+        
+        return connected_blocks, has_yard
+
     def _parse_infrastructure(self, infra_str: str, block_num: int, line: str) -> Tuple[
         bool, Optional[Station], bool, Optional[Switch], bool, bool]:
         """
@@ -695,6 +778,10 @@
                         station.side = self._normalize_platform_side(row['Station Side'])
                         self._debug_print(f"  -> Updated station side to: {station.side}")
 
+                    # Parse connected blocks data - NEW
+                    connected_blocks, has_yard_connection = self._parse_connected_blocks(row.get('Connected Blocks'))
+                    self._debug_print(f"  -> Connected blocks for {block_num}: {connected_blocks}, yard: {has_yard_connection}")
+
                     # Create track block with safer data extraction
                     try:
                         block = TrackBlock(
@@ -711,7 +798,9 @@
                             has_switch=has_switch,
                             switch=switch,
                             has_crossing=has_crossing,
-                            is_underground=is_underground
+                            is_underground=is_underground,
+                            connected_blocks=connected_blocks,
+                            has_yard_connection=has_yard_connection
                         )
                     except (ValueError, TypeError) as e:
                         self._debug_print(f"  Error creating block {block_num}: {e}")
Index: CTC/Utils/update_worker_documentation.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/CTC/Utils/update_worker_documentation.md b/CTC/Utils/update_worker_documentation.md
new file mode 100644
--- /dev/null	(date 1752377461211)
+++ b/CTC/Utils/update_worker_documentation.md	(date 1752377461211)
@@ -0,0 +1,132 @@
+# UpdateWorker Class Documentation
+
+## Overview
+The UpdateWorker class (`update_worker.py`) is a threading utility for handling system updates at different frequencies. It has been updated to work with the migrated CTC System architecture.
+
+## Attributes
+
+### Instance Attributes
+- `ctcOffice`: Reference to the CTC Office main application
+- `running` (bool): Thread running flag
+- `updateCounter` (int): Counter for tracking update cycles
+
+## Qt Signals
+
+### Update Signals
+- `updateData`: High frequency signal for data-only updates (emitted every 100ms)
+- `updateTables`: Medium frequency signal for table content updates (emitted every 500ms)
+- `updateVisuals`: Low frequency signal for charts/plots updates (emitted every 2 seconds)
+
+## Methods
+
+### Core Methods
+- `__init__(ctc_office)`: Initialize with reference to CTC Office application
+- `run()`: Main update loop with different frequencies for different components
+- `stop()`: Stop the update worker thread safely
+
+## Update Frequencies
+
+### High Frequency (100ms / 10Hz)
+- **Purpose**: Real-time data updates that need immediate reflection
+- **Signal**: `updateData`
+- **Use Cases**:
+  - Train position updates
+  - Block occupation status
+  - Speed and authority changes
+  - Emergency alerts
+
+### Medium Frequency (500ms / 2Hz)
+- **Purpose**: Table content updates that change moderately
+- **Signal**: `updateTables`
+- **Use Cases**:
+  - Train status tables
+  - Block status tables
+  - Emergency/failure tables
+  - System metrics displays
+
+### Low Frequency (2 seconds / 0.5Hz)
+- **Purpose**: Resource-intensive visual updates
+- **Signal**: `updateVisuals`
+- **Use Cases**:
+  - Track layout diagrams
+  - Charts and graphs
+  - Throughput visualizations
+  - System overview displays
+
+## System Integration
+
+### CTC System Integration
+The UpdateWorker integrates with the new CTC System architecture:
+
+```python
+# Get the CTC system instance
+ctc_system = getattr(self.ctcOffice, 'ctc_system', None)
+
+# System tick for CTC system (replaces individual manager updates)
+ctc_system.system_tick(current_time)
+```
+
+### Time Management
+- Attempts to use Master Interface time for synchronized operation
+- Falls back to real-time if Master Interface isn't available
+- Supports time acceleration through the time multiplier system
+
+### Error Handling
+- Comprehensive exception handling to prevent thread crashes
+- Automatic recovery with delayed retry on errors
+- Debug logging for troubleshooting update issues
+
+## Threading Considerations
+
+### Thread Safety
+- Runs in separate QThread to avoid blocking UI
+- Uses Qt signal/slot mechanism for thread-safe communication
+- All UI updates must be performed in the main thread
+
+### Performance Optimization
+- Different update frequencies prevent unnecessary computation
+- High frequency updates focus on critical real-time data
+- Low frequency updates handle resource-intensive operations
+- Update counter prevents simultaneous heavy operations
+
+### Resource Management
+- Automatic cleanup when stopping
+- Graceful shutdown with thread joining
+- Memory-efficient operation with minimal overhead
+
+## Integration Notes
+
+### With CTC Office Application
+- Designed to work with the main CTC Office GUI application
+- Expects `ctc_system` attribute on the CTC Office instance
+- Supports applications with or without Master Interface integration
+
+### With UI Frameworks
+- Compatible with PyQt5/PyQt6 applications
+- Can be adapted for other GUI frameworks by changing signal mechanism
+- Signals can be replaced with callback functions for non-Qt applications
+
+### With System Architecture
+- Replaces individual manager update loops with unified system tick
+- Supports the consolidated CTC System architecture
+- Maintains backward compatibility with existing UI update patterns
+
+## Best Practices
+
+### UI Responsiveness
+1. Keep high frequency update handlers lightweight
+2. Batch database/file operations in medium frequency updates
+3. Perform expensive rendering in low frequency updates
+4. Use background processing for non-critical updates
+
+### Error Recovery
+1. Implement robust error handling in signal handlers
+2. Log errors for debugging without crashing the update loop
+3. Provide fallback behavior for missing system components
+4. Test update frequency changes under various load conditions
+
+### Performance Monitoring
+1. Monitor update loop performance under various conditions
+2. Adjust frequencies based on system capabilities
+3. Profile individual update handlers to identify bottlenecks
+4. Consider adaptive frequency adjustment based on system load
\ No newline at end of file
Index: CTC/Core/route.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\nRoute Module\n===========\nDefines the Route class according to UML specifications.\nManages train routes with authority and speed sequences.\n\nThis module handles:\n- Route creation and validation\n- Block sequence management\n- Authority and speed calculations\n- Location tracking and updates\n\"\"\"\n\nfrom typing import List, Tuple, Optional\nfrom datetime import datetime, timedelta\nimport logging\n\n# Set up logging\nlogger = logging.getLogger(__name__)\n\n\nclass Route:\n    \"\"\"\n    Route class implementing UML interface\n    Represents a train route with all associated control information\n    \"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize Route with UML-specified attributes\"\"\"\n        # Attributes from UML\n        self.routeID = None            # String\n        self.startBlock = None         # Block object\n        self.endBlock = None           # Block object\n        self.blockSequence = []        # List[Block]\n        self.estimatedTravelTime = 0.0 # float (seconds)\n        \n        # Additional attributes needed for implementation\n        self.authoritySequence = []    # List[int] - authority for each block (0 or 1)\n        self.speedSequence = []        # List[int] - speed for each block (0-3)\n        self.currentBlockIndex = 0     # Current position in route\n        self.isActive = False\n        self.trainID = None\n        self.scheduledDeparture = None # DateTime\n        self.actualDeparture = None    # DateTime\n        self.scheduledArrival = None   # DateTime\n        self.actualArrival = None      # DateTime\n        \n        # Route metadata\n        self.routeType = 'NORMAL'      # NORMAL, EMERGENCY, MAINTENANCE\n        self.priority = 1              # 1=low, 2=medium, 3=high\n        self.createdTime = datetime.now()\n        self.lastUpdate = datetime.now()\n        \n        # Safety and operational data\n        self.totalDistance = 0.0       # Total route distance in meters\n        self.maxSpeed = 0              # Maximum speed for route\n        self.grade_profile = []        # Grade information for each block\n        self.station_stops = []        # List of station stops\n        \n        logger.debug(f\"New route initialized\")\n    \n    # Methods from UML\n    \n    def create_route(self, start, end, arrivalTime: datetime) -> None:\n        \"\"\"\n        Create route from start to end\n        \n        Args:\n            start: Block object for route start\n            end: Block object for route destination  \n            arrivalTime: Desired arrival time\n        \"\"\"\n        self.startBlock = start\n        self.endBlock = end\n        self.scheduledArrival = arrivalTime\n        \n        # Generate unique route ID\n        self.routeID = f\"route_{start.blockID}_{end.blockID}_{int(datetime.now().timestamp())}\"\n        \n        # Calculate block sequence (will be enhanced with full routing logic)\n        self.blockSequence = self._calculate_block_sequence(start, end)\n        \n        # Calculate travel time and other parameters\n        self._calculate_route_parameters()\n        \n        # Initialize authority and speed sequences\n        self.calculate_authority_speed()\n        \n        self.lastUpdate = datetime.now()\n        logger.info(f\"Route {self.routeID} created: Block {start.blockID} to Block {end.blockID}\")\n    \n    def validate_route(self) -> bool:\n        \"\"\"\n        Validate route is traversable\n        \n        Returns:\n            True if route is valid and safe\n        \"\"\"\n        if not self.blockSequence:\n            logger.warning(f\"Route {self.routeID} validation failed: empty block sequence\")\n            return False\n        \n        if not self.startBlock or not self.endBlock:\n            logger.warning(f\"Route {self.routeID} validation failed: missing start/end blocks\")\n            return False\n        \n        # Check block connectivity\n        for i in range(len(self.blockSequence) - 1):\n            current_block = self.blockSequence[i]\n            next_block = self.blockSequence[i + 1]\n            \n            if not self._blocks_connected(current_block, next_block):\n                logger.warning(f\"Route {self.routeID} validation failed: blocks {current_block.blockID} and {next_block.blockID} not connected\")\n                return False\n        \n        # Check for operational blocks\n        for block in self.blockSequence:\n            if not block.block_operational():\n                logger.warning(f\"Route {self.routeID} validation failed: block {block.blockID} not operational\")\n                return False\n        \n        # Check timing feasibility\n        if not self._validate_timing():\n            logger.warning(f\"Route {self.routeID} validation failed: timing not feasible\")\n            return False\n        \n        logger.info(f\"Route {self.routeID} validated successfully\")\n        return True\n    \n    def get_next_block(self):\n        \"\"\"\n        Get next block in sequence\n        \n        Returns:\n            Next Block object in route, or None if at end\n        \"\"\"\n        if self.currentBlockIndex < len(self.blockSequence) - 1:\n            return self.blockSequence[self.currentBlockIndex + 1]\n        return None\n    \n    def update_location(self, newBlock) -> None:\n        \"\"\"\n        Update train position in route\n        \n        Args:\n            newBlock: Block object where train is now located\n        \"\"\"\n        # Find block in sequence\n        new_block_id = newBlock.blockID if hasattr(newBlock, 'blockID') else newBlock\n        \n        for i, block in enumerate(self.blockSequence):\n            if block.blockID == new_block_id:\n                old_index = self.currentBlockIndex\n                self.currentBlockIndex = i\n                self.lastUpdate = datetime.now()\n                \n                # Update actual departure time if this is the first move\n                if old_index == 0 and i > 0 and not self.actualDeparture:\n                    self.actualDeparture = datetime.now()\n                \n                # Update actual arrival time if reached destination\n                if i == len(self.blockSequence) - 1 and not self.actualArrival:\n                    self.actualArrival = datetime.now()\n                \n                logger.debug(f\"Route {self.routeID} position updated: block index {old_index} -> {i}\")\n                return\n        \n        logger.warning(f\"Route {self.routeID}: block {new_block_id} not found in sequence\")\n    \n    def get_block_sequence(self) -> List:\n        \"\"\"\n        Get full block sequence\n        \n        Returns:\n            List of Block objects in route order\n        \"\"\"\n        return self.blockSequence.copy()\n    \n    # Additional methods needed for implementation\n    \n    def calculate_authority_speed(self) -> None:\n        \"\"\"\n        Calculate authority and speed for each block in route\n        Updates authoritySequence and speedSequence based on current conditions\n        \"\"\"\n        self.authoritySequence = []\n        self.speedSequence = []\n        \n        for i, block in enumerate(self.blockSequence):\n            # Calculate authority (0 = no authority, 1 = full authority)\n            authority = self._calculate_block_authority(block, i)\n            self.authoritySequence.append(authority)\n            \n            # Calculate suggested speed (0=stop, 1=1/3, 2=2/3, 3=full)\n            speed = self._calculate_block_speed(block, i)\n            self.speedSequence.append(speed)\n        \n        logger.debug(f\"Route {self.routeID} authority/speed sequences updated\")\n    \n    def update_for_conditions(self, track_conditions: dict) -> None:\n        \"\"\"\n        Update authority/speed based on current conditions\n        \n        Args:\n            track_conditions: Dictionary of current track conditions\n        \"\"\"\n        # Store track conditions\n        self.track_conditions = track_conditions\n        \n        # Recalculate authority and speed\n        self.calculate_authority_speed()\n        \n        # Update estimated travel time if needed\n        self._recalculate_travel_time()\n        \n        self.lastUpdate = datetime.now()\n        logger.debug(f\"Route {self.routeID} updated for current conditions\")\n    \n    def get_lookahead_info(self, numBlocks: int) -> Tuple[List[int], List[int]]:\n        \"\"\"\n        Get authority/speed for next N blocks from current position\n        \n        Args:\n            numBlocks: Number of blocks ahead to return\n            \n        Returns:\n            Tuple of (authority_list, speed_list) for next N blocks\n        \"\"\"\n        start_index = self.currentBlockIndex\n        end_index = min(start_index + numBlocks, len(self.blockSequence))\n        \n        authority_ahead = self.authoritySequence[start_index:end_index]\n        speed_ahead = self.speedSequence[start_index:end_index]\n        \n        # Pad with zeros if needed\n        while len(authority_ahead) < numBlocks:\n            authority_ahead.append(0)\n        while len(speed_ahead) < numBlocks:\n            speed_ahead.append(0)\n        \n        return authority_ahead[:numBlocks], speed_ahead[:numBlocks]\n    \n    def get_remaining_blocks(self) -> List:\n        \"\"\"\n        Get blocks remaining in route from current position\n        \n        Returns:\n            List of Block objects from current position to end\n        \"\"\"\n        return self.blockSequence[self.currentBlockIndex:]\n    \n    def get_progress_percentage(self) -> float:\n        \"\"\"\n        Get route completion percentage\n        \n        Returns:\n            Percentage of route completed (0.0 to 100.0)\n        \"\"\"\n        if not self.blockSequence:\n            return 0.0\n        \n        return (self.currentBlockIndex / len(self.blockSequence)) * 100.0\n    \n    def get_estimated_arrival(self) -> Optional[datetime]:\n        \"\"\"\n        Get estimated arrival time based on current position and conditions\n        \n        Returns:\n            Estimated arrival datetime, or None if cannot calculate\n        \"\"\"\n        if not self.isActive or self.currentBlockIndex >= len(self.blockSequence):\n            return self.actualArrival\n        \n        # Calculate remaining time based on remaining blocks and current speeds\n        remaining_time = 0.0\n        \n        for i in range(self.currentBlockIndex, len(self.blockSequence)):\n            block = self.blockSequence[i]\n            speed_command = self.speedSequence[i] if i < len(self.speedSequence) else 1\n            \n            # Convert speed command to actual speed\n            actual_speed = self._speed_command_to_kmh(speed_command, block.speedLimit)\n            \n            # Calculate block traversal time\n            if actual_speed > 0:\n                block_time = (block.length / 1000.0) / actual_speed * 3600  # Convert to seconds\n                remaining_time += block_time\n        \n        return datetime.now() + timedelta(seconds=remaining_time)\n    \n    def add_station_stop(self, block, stop_duration: float) -> None:\n        \"\"\"\n        Add station stop to route\n        \n        Args:\n            block: Block object with station\n            stop_duration: Stop duration in seconds\n        \"\"\"\n        if hasattr(block, 'station') and block.station:\n            stop_info = {\n                'block': block,\n                'station_name': block.station.name,\n                'duration': stop_duration,\n                'scheduled_time': None,\n                'actual_arrival': None,\n                'actual_departure': None\n            }\n            self.station_stops.append(stop_info)\n            logger.info(f\"Station stop added to route {self.routeID}: {block.station.name}\")\n    \n    def activate_route(self, train_id: str) -> None:\n        \"\"\"\n        Activate route for a specific train\n        \n        Args:\n            train_id: ID of train using this route\n        \"\"\"\n        self.isActive = True\n        self.trainID = train_id\n        self.actualDeparture = datetime.now()\n        \n        logger.info(f\"Route {self.routeID} activated for train {train_id}\")\n    \n    def deactivate_route(self) -> None:\n        \"\"\"Deactivate route when train reaches destination\"\"\"\n        self.isActive = False\n        if not self.actualArrival:\n            self.actualArrival = datetime.now()\n        \n        logger.info(f\"Route {self.routeID} deactivated\")\n    \n    # Private helper methods\n    \n    def _calculate_block_sequence(self, start_block, end_block) -> List:\n        \"\"\"\n        Calculate sequence of blocks from start to end\n        This is a simplified implementation - full routing would use track topology\n        \"\"\"\n        sequence = []\n        \n        # Simple linear progression for now\n        start_id = start_block.blockID\n        end_id = end_block.blockID\n        \n        if start_id < end_id:\n            # Forward direction\n            current_id = start_id\n            while current_id <= end_id:\n                # Create placeholder block (would use actual Block objects)\n                block = type('Block', (), {'blockID': current_id, 'length': 100, 'speedLimit': 50})()\n                sequence.append(block)\n                current_id += 1\n        else:\n            # Backward direction\n            current_id = start_id\n            while current_id >= end_id:\n                block = type('Block', (), {'blockID': current_id, 'length': 100, 'speedLimit': 50})()\n                sequence.append(block)\n                current_id -= 1\n        \n        return sequence\n    \n    def _calculate_route_parameters(self):\n        \"\"\"Calculate route distance, time, and other parameters\"\"\"\n        self.totalDistance = sum(block.length for block in self.blockSequence)\n        self.maxSpeed = max(block.speedLimit for block in self.blockSequence) if self.blockSequence else 0\n        \n        # Calculate estimated travel time (simplified)\n        if self.maxSpeed > 0:\n            # Assume average speed is 60% of max speed\n            avg_speed = self.maxSpeed * 0.6\n            self.estimatedTravelTime = (self.totalDistance / 1000.0) / avg_speed * 3600  # seconds\n        \n        # Set scheduled departure to allow time for travel\n        if self.scheduledArrival:\n            self.scheduledDeparture = self.scheduledArrival - timedelta(seconds=self.estimatedTravelTime)\n    \n    def _calculate_block_authority(self, block, block_index: int) -> int:\n        \"\"\"Calculate authority for specific block\"\"\"\n        # Check basic operability\n        if not hasattr(block, 'block_operational') or not block.block_operational():\n            return 0\n        \n        # Check if block is occupied\n        if hasattr(block, 'occupied') and block.occupied:\n            return 0\n        \n        # Check for maintenance\n        if hasattr(block, 'maintenance_mode') and block.maintenance_mode:\n            return 0\n        \n        # Default to full authority\n        return 1\n    \n    def _calculate_block_speed(self, block, block_index: int) -> int:\n        \"\"\"Calculate speed command for specific block\"\"\"\n        # No authority = stop\n        if self.authoritySequence and block_index < len(self.authoritySequence):\n            if self.authoritySequence[block_index] == 0:\n                return 0\n        \n        # Check for station stops\n        for stop in self.station_stops:\n            if stop['block'].blockID == block.blockID:\n                return 1  # Approach speed for station\n        \n        # Check grade\n        if hasattr(block, 'grade') and abs(block.grade) > 5.0:\n            return 2  # Reduced speed for steep grade\n        \n        # Check if approaching end of route\n        if block_index >= len(self.blockSequence) - 2:\n            return 2  # Reduced speed approaching destination\n        \n        # Default to full speed\n        return 3\n    \n    def _blocks_connected(self, block1, block2) -> bool:\n        \"\"\"Check if two blocks are connected\"\"\"\n        # Simplified - just check if block numbers are adjacent\n        return abs(block1.blockID - block2.blockID) == 1\n    \n    def _validate_timing(self) -> bool:\n        \"\"\"Validate route timing is feasible\"\"\"\n        if not self.scheduledArrival or not self.estimatedTravelTime:\n            return True  # No timing constraints\n        \n        earliest_arrival = datetime.now() + timedelta(seconds=self.estimatedTravelTime)\n        return self.scheduledArrival >= earliest_arrival\n    \n    def _speed_command_to_kmh(self, speed_command: int, speed_limit: float) -> float:\n        \"\"\"Convert speed command to actual speed in km/h\"\"\"\n        speed_map = {\n            0: 0.0,                    # Stop\n            1: speed_limit * 0.33,     # 1/3 speed\n            2: speed_limit * 0.67,     # 2/3 speed\n            3: speed_limit             # Full speed\n        }\n        return speed_map.get(speed_command, 0.0)\n    \n    def _recalculate_travel_time(self):\n        \"\"\"Recalculate travel time based on current speed restrictions\"\"\"\n        total_time = 0.0\n        \n        for i, block in enumerate(self.blockSequence[self.currentBlockIndex:], self.currentBlockIndex):\n            speed_command = self.speedSequence[i] if i < len(self.speedSequence) else 1\n            actual_speed = self._speed_command_to_kmh(speed_command, block.speedLimit)\n            \n            if actual_speed > 0:\n                block_time = (block.length / 1000.0) / actual_speed * 3600\n                total_time += block_time\n        \n        self.estimatedTravelTime = total_time\n    \n    def __str__(self) -> str:\n        \"\"\"String representation of route\"\"\"\n        status = \"active\" if self.isActive else \"inactive\"\n        return f\"Route {self.routeID} ({status}): Block {self.startBlock.blockID if self.startBlock else 'None'} to {self.endBlock.blockID if self.endBlock else 'None'}\"\n    \n    def __repr__(self) -> str:\n        \"\"\"Detailed representation of route\"\"\"\n        return (f\"Route(id={self.routeID}, start={self.startBlock.blockID if self.startBlock else None}, \"\n                f\"end={self.endBlock.blockID if self.endBlock else None}, active={self.isActive}, \"\n                f\"progress={self.currentBlockIndex}/{len(self.blockSequence)})\")
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/CTC/Core/route.py b/CTC/Core/route.py
--- a/CTC/Core/route.py	(revision 58821640d3fc1243a45beca7e2f7ac46d5ad7247)
+++ b/CTC/Core/route.py	(date 1752438455856)
@@ -333,25 +333,73 @@
     
     def _calculate_block_sequence(self, start_block, end_block) -> List:
         """
-        Calculate sequence of blocks from start to end
-        This is a simplified implementation - full routing would use track topology
+        Calculate sequence of blocks from start to end using connected_blocks data
+        """
+        from collections import deque
+        
+        start_id = start_block.blockID
+        end_id = end_block.blockID
+        
+        # If start and end are the same, return just that block
+        if start_id == end_id:
+            return [start_block]
+        
+        # Use breadth-first search to find path using connected_blocks
+        queue = deque([(start_id, [start_block])])
+        visited = {start_id}
+        
+        # Get all blocks from the system for reference
+        try:
+            all_blocks = self._get_all_blocks_on_line(start_block.line)
+            block_lookup = {block.blockID: block for block in all_blocks}
+        except (AttributeError, TypeError):
+            # Fallback if _get_all_blocks_on_line is not available
+            return self._calculate_block_sequence_legacy(start_block, end_block)
+        
+        while queue:
+            current_id, path = queue.popleft()
+            current_block = block_lookup.get(current_id)
+            
+            if not current_block:
+                continue
+                
+            # Check all connected blocks
+            for next_id in current_block.get_connected_blocks():
+                if next_id in visited:
+                    continue
+                
+                next_block = block_lookup.get(next_id)
+                if not next_block:
+                    continue
+                
+                new_path = path + [next_block]
+                
+                # Found destination
+                if next_id == end_id:
+                    return new_path
+                
+                # Add to queue for further exploration
+                queue.append((next_id, new_path))
+                visited.add(next_id)
+        
+        # Fallback to legacy linear progression if pathfinding fails
+        return self._calculate_block_sequence_legacy(start_block, end_block)
+    
+    def _calculate_block_sequence_legacy(self, start_block, end_block) -> List:
+        """
+        Legacy calculation using sequential block numbers (fallback only)
         """
         sequence = []
-        
-        # Simple linear progression for now
         start_id = start_block.blockID
         end_id = end_block.blockID
         
         if start_id < end_id:
-            # Forward direction
             current_id = start_id
             while current_id <= end_id:
-                # Create placeholder block (would use actual Block objects)
                 block = type('Block', (), {'blockID': current_id, 'length': 100, 'speedLimit': 50})()
                 sequence.append(block)
                 current_id += 1
         else:
-            # Backward direction
             current_id = start_id
             while current_id >= end_id:
                 block = type('Block', (), {'blockID': current_id, 'length': 100, 'speedLimit': 50})()
@@ -416,8 +464,12 @@
         return 3
     
     def _blocks_connected(self, block1, block2) -> bool:
-        """Check if two blocks are connected"""
-        # Simplified - just check if block numbers are adjacent
+        """Check if two blocks are connected using connected_blocks data"""
+        # Use connected_blocks data if available
+        if hasattr(block1, 'is_connected_to'):
+            return block1.is_connected_to(block2.blockID)
+        
+        # Fallback to legacy adjacent check
         return abs(block1.blockID - block2.blockID) == 1
     
     def _validate_timing(self) -> bool:
@@ -438,6 +490,12 @@
         }
         return speed_map.get(speed_command, 0.0)
     
+    def _get_all_blocks_on_line(self, line: str):
+        """Helper method to get all blocks on a line - should be implemented by system"""
+        # This method should be implemented by the CTC system that uses this Route class
+        # For now, return empty list to trigger fallback
+        return []
+    
     def _recalculate_travel_time(self):
         """Recalculate travel time based on current speed restrictions"""
         total_time = 0.0
